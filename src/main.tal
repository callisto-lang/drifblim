( Drifblim )

|00 @System     &vector $2 &wst      $1 &rst    $1 &eaddr  $2 &ecode  $1 &pad     $1 &r       $2 &g      $2 &b     $2 &debug  $1 &halt $1
|10 @Console    &vector $2 &read     $1 &pad    $5 &write  $1 &error  $1
|a0 @File       &vector $2 &success  $2 &stat   $2 &delete $1 &append $1 &name    $2 &length  $2 &read   $2 &write $2

%EMIT { #18 DEO }
%HALT { #010f DEO }
%PRINT  { ;print-str JSR2 #0a EMIT }
%DEBUG  { ;print/byte JSR2 #0a EMIT }
%DEBUG2 { ;print/short JSR2 #0a EMIT }
%RTN { JMP2r }

%+  { ADD }  %-  { SUB }  %*  { MUL }  %/  { DIV }
%<  { LTH }  %>  { GTH }  %=  { EQU }  %!  { NEQ }
%++ { ADD2 } %-- { SUB2 } %** { MUL2 } %// { DIV2 }
%<< { LTH2 } %>> { GTH2 } %== { EQU2 } %!! { NEQ2 }

%=~ { EQUk NIP } %!~ { NEQk NIP }
%<~ { LTHk NIP } %>~ { GTHk NIP }

|0000

	@src $40
	@token $40
	@sleep $1
	@p 
		&ptr $2
		&len $2

|0100

	;on-console .Console/vector DEO2 

BRK

@on-console ( -> )

	.Console/read DEI
	DUP #20 < ,&end JCN
	DUP #7f > ,&end JCN
	;src ;slen JSR2 #003f >> ,&end JCN
		;src ROT ;sput JSR2 BRK
		&end
	;src ;first-pass JSR2
	POP 

	( make rom )
	;&rom-ext ;src ;scap JSR2 #0003 -- ;scpy JSR2
	;src .File/name DEO2
	.p/len LDZ2 #0100 -- .File/length DEO2
	;dst #0100 ++ .File/write DEO2

	HALT

BRK

	&rom-ext "rom $1

@first-pass ( src* -- )

	.File/name DEO2
	#0001 .File/length DEO2
	&stream
		;&c
			DUP2 .File/read DEO2
			( comment )
			LDAk #28 ! ,&no-sleep JCN
				#01 .sleep STZ
				&no-sleep
			LDAk #29 ! ,&no-wake JCN
				#00 .sleep STZ
				,&no-cap JMP
				&no-wake
			.sleep LDZ ,&no-cap JCN
			( listen )
			LDAk #21 < ,&no-put JCN
				LDAk ;token ;scap JSR2 STA
				&no-put
			LDAk #20 > ,&no-cap JCN
				;find-token JSR2
				;token #0040 ;mclr JSR2
				&no-cap
		POP2
		.File/success DEI2 ORA ,&stream JCN
	HALT

RTN
	&c $1

@find-token ( -- )

	( skip blank ) ;token ;slen JSR2 ORA #01 JCN RTN

	;token LDA STH
	;syntax/end ;syntax
	&loop
		LDAk STHkr ! ,&no-found JCN
			POPr INC2k LDA2 JMP2
			&no-found
		INC2 INC2 INC2 GTH2k ,&loop JCN
	POP2 POP2
	POPr
	;token ;is-byte JSR2 ;token-rawbyte JCN2
	;token ;is-short JSR2 ;token-rawshort JCN2
	;token ;is-opcode JSR2 ;token-opcode JCN2
	;token ;is-macro JSR2 ;token-macro JCN2
	;token ;unknown-token-txt ;print-error JSR2

RTN

@unknown-token-txt "unknown-token $1

@token-include ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-macro ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-padabs ( -- )

	;token INC2 ;is-short JSR2 #00 = ,&invalid JCN
		;token INC2 ;sshort JSR2 .p/ptr STZ2
		RTN
	&invalid
	;token ;&error-invalid-hex ;print-error JSR2

RTN
	&error-invalid-hex "invalid-hex $1

@token-padrel ( -- )

	;token INC2 ;is-byte JSR2 #00 = ,&invalid JCN
		#00 ;token INC2 ;sbyte JSR2 .p/ptr STZ2
		RTN
	&invalid
	;token ;&error-invalid-hex ;print-error JSR2

RTN
	&error-invalid-hex "invalid-hex $1

@token-opcode ( -- )
	( ;token ;TODO ;print-error JSR2 )

RTN

@token-litlabel ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-litsublabel ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-lithex ( -- )

	;token INC2 ;validate-hex JSR2 #00 = ,&invalid JCN

	;token INC2 ;is-short JSR2 #00 = ,&no-short JCN
		;token INC2 ;sshort JSR2 ;write-litshort JSR2 RTN
		&no-short
	;token INC2 ;is-byte JSR2 #00 = ,&no-byte JCN
		;token INC2 ;sbyte JSR2 ;write-litbyte JSR2 RTN
		&no-byte
	&invalid
	;token ;&error-invalid-hex ;print-error JSR2

RTN
	&error-invalid-hex "invalid-lithex $1

@token-litzp ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-litrel ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-litabs ( -- )
	;token ;TODO ;print-error JSR2

RTN

@token-rawabs ( -- )

	;token ;TODO ;print-error JSR2

RTN

@token-rawchr ( -- )

	;token LDAk ;write-byte JSR2

RTN

@token-rawstr ( -- )
	
	;token
	&while
		LDAk ;write-byte JSR2
		INC2 LDAk ,&while JCN
	POP2

RTN

@token-rawshort ( -- )

	;token ;sshort JSR2 ;write-short JSR2

RTN

@token-rawbyte ( -- )

	;token ;sbyte JSR2 ;write-byte JSR2

RTN

@token-ignored ( -- )

RTN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&loop
		#00 OVR #20 SFT2 ;opcodes ++ STH2kr ;scmp-seg JSR2 #00 = ,&continue JCN
			NIP STH2r ,find-mode JSR + RTN
			&continue
		INC GTHk ,&loop JCN
	POP2
	POP2r
	#00

RTN

@find-mode ( mode* -- byte )

	LITr 00
	;opcodes OVR2 ;scmp-seg JSR2 #70 SFT STH ADDr
	#0003 ++
	LDAk #00 = ,&end JCN
	&while
		LDAk LIT '2 = #50 SFT STH ADDr
		LDAk LIT 'r = #60 SFT STH ADDr
		LDAk LIT 'k = #70 SFT STH ADDr
		INC2 LDAk ,&while JCN
	&end
	POP2
	STHr

RTN

@TODO "TODO $1

@syntax
	'~ :token-include  '% :token-macro
	'| :token-padabs   '$ :token-padrel
	'@ :token-litlabel '& :token-litsublabel
	'# :token-lithex   '. :token-litzp
	', :token-litrel   '; :token-litabs
	': :token-rawabs   '' :token-rawchr
	'" :token-rawstr   '[ :token-ignored
	'] :token-ignored  &end

@opcodes
	"LIT $1 "INC $1 "POP $1 "DUP $1 "NIP $1 "SWP $1 "OVR $1 "ROT $1
	"EQU $1 "NEQ $1 "GTH $1 "LTH $1 "JMP $1 "JCN $1 "JSR $1 "STH $1
	"LDZ $1 "STZ $1 "LDR $1 "STR $1 "LDA $1 "STA $1 "DEI $1 "DEO $1
	"ADD $1 "SUB $1 "MUL $1 "DIV $1 "AND $1 "ORA $1 "EOR $1 "SFT $1

( ------------------------------------------------------------------------ )

@write-litshort ( short* -- )

	( LIT2k ) #0a ,write-byte JSR 
	,write-short JSR

RTN

@write-litbyte ( byte -- )

	( LITk ) #08 ,write-byte JSR
	,write-byte JSR

RTN

@write-short ( short -- )

	SWP ,write-byte JSR
	,write-byte JSR

RTN

@write-byte ( byte -- )

	;dst .p/ptr LDZ2 ++ STA
	( incr ptr ) .p/ptr LDZ2k INC2 ROT STZ2
	( set length ) .p/ptr LDZ2 .p/len STZ2

RTN

@is-opcode ( string* -- bool )

	;&brk-txt OVR ;scmp-seg JSR2 #00 = ,&continue JCN
		POP2 #01 RTN
		&continue
	;find-opcode JSR2 

RTN
	&brk-txt "BRK $1

@is-macro ( string* -- bool )

	POP2 #00

RTN

@is-byte ( string* -- bool )

	DUP2 ;slen JSR2 #0002 == STH
	;validate-hex JSR2 STHr AND

RTN

@is-short ( string* -- bool )

	DUP2 ;slen JSR2 #0004 == STH
	;validate-hex JSR2 STHr AND 

RTN

@validate-hex ( value* -- bool )

	&while
		LDAk DUP #2f > SWP #3a < AND ,&valid JCN
		LDAk DUP #60 > SWP #67 < AND ,&valid JCN
			POP2 #00 RTN
			&valid
		INC2 LDAk ,&while JCN
	POP2
	#01

RTN

@sshort ( str* -- short* )

	INC2k INC2 ,sbyte JSR STH
	,sbyte JSR STHr

RTN

@sbyte ( str* -- byte )

	LDAk ,chex JSR STH
	INC2 LDA ,chex JSR
	STHr #40 SFT ADD

RTN

@chex ( char -- hex )

	DUP #2f > OVR #3a < AND ,&number JCN
	DUP #60 > OVR #67 < AND ,&lc JCN
	DUP #40 > OVR #47 < AND ,&uc JCN
		POP #00 RTN
	&number #30 - RTN
	&uc #37 - RTN
	&lc #57 - RTN

RTN

( helpers )

@mclr ( addr* len* -- )

	OVR2 ++ SWP2
	&loop
		STH2k #00 STH2r STA
		INC2 GTH2k ,&loop JCN
	POP2 POP2

RTN

@slen ( str* -- len* )

	DUP2 ,scap JSR SWP2 --

RTN

@scap ( str* -- str-end* )

	LDAk #00 ! JMP RTN
	&while INC2 LDAk ,&while JCN

RTN

@scpy ( src* dst* -- )
	
	STH2
	&while
		LDAk STH2kr STA INC2r
		INC2 LDAk ,&while JCN
	POP2
	#00 STH2r STA

JMP2r

@sput ( str* char -- )

	ROT ROT ,scap JSR STA

RTN

@spop ( str* -- )

	LDAk ,&no-null JCN
		POP2 RTN &no-null
	#00 ROT ROT ,scap JSR #0001 -- STA

RTN

@scmp-seg ( a* b* -- flag )

	STH2
	&loop
		LDAk LDAkr STHr = ,&not-diff JCN
			POP2 POP2r #00 JMP2r
			&not-diff
		INC2k LDA #00 ! ,&continue JCN
			POP2 POP2r #01 JMP2r
			&continue
		INC2 INC2r
		,&loop JMP
	POP2 POP2r #00

JMP2r

@print ( short* -- )

	&short ( short* -- ) SWP ,&byte JSR
	&byte ( byte -- ) DUP #04 SFT ,&char JSR
	&char ( char -- ) #0f AND DUP #09 GTH #27 MUL ADD #30 ADD EMIT

RTN

@print-error ( token* error* -- )

	SWP2 ;print-str JSR2 #20 EMIT PRINT

RTN

@print-str ( str* -- )

	#0001 SUB2
	&while
		INC2 LDAk DUP EMIT ,&while JCN
	POP2

RTN

@dst
