( Usage: uxncli driflim.rom src/source.tal )

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &err $1
|a0 @File &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|b0 @File2 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@src $40
	@inc $40
	@buf $40
	@scope $30
	@token $30
	@p &ptr $2 &len $2
	@sym &ptr $2

|0100

	;on-console .Console/vector DEO2

BRK

@on-console ( -> )

	;src STH2
	( filepath )
	.Console/read DEI
	DUP #20 LTH OVR #7f GTH ORA ,&end JCN
	STH2kr ;slen JSR2 #003f GTH2 ,&end JCN
		STH2r ;sput JSR2 BRK
		&end
	POP
	( assemble )
	STH2r ,assemble JSR

	( print symbols )
	;print-symbols JSR2

	( halt )
	#010e DEO
	#010f DEO

BRK

@assemble ( file* -- )

	( prepare output )
	DUP2 ;dst #0040 ;mcpy JSR2
	;&rom-ext ;dst ;scap JSR2 #0004 SUB2 ;scpy JSR2
	;dst .File2/name DEO2
	#0001 .File/length DEO2
	( stream )
	.File/name DEO2
	#0001 .File/length DEO2
	&stream
		;&c .File/read DEO2
		.File/success DEI2 #0000 EQU2 ,&eof JCN
		[ LIT &c $1 ] ,walk JSR
		,&stream JMP &eof

JMP2r
	&rom-ext ".rom $1

@walk ( char -- )

	#20 GTHk NIP ,&append JCN POP
	;token DUP2 ;slen JSR2 ORA ,&run JCN POP2

JMP2r
	&run DUP2 ,walk-token JSR #0030 ;mclr JSR2 JMP2r
	&append ;token ;sput JMP2

@walk-token ( token* -- )

	LDAk LIT '( EQU ,&on-parens JCN
	LDAk LIT ') EQU ,&on-parens JCN
	[ LIT &sleep $1 ] ,&on-sleep JCN

	( print )
	.p/ptr LDZ2 ;print JSR2 #2018 DEO
	DUP2 ;find-token JSR2 INC2 LDA2 ;print JSR2 #2018 DEO
	DUP2 ;pstr JSR2 #0a18 DEO

	( pass1 token )
	DUP2 ;find-token JSR2 INC2 LDA2 JSR2

JMP2r
	&on-parens LDA #29 SUB ,&sleep STR JMP2r
	&on-sleep POP2 JMP2r

@find-token ( token* -- type* )

	STH2
	( runes )
	;runes/err ;runes
	&loop
		LDAk STH2kr LDA EQU ,&on-runic JCN
		INC2 INC2 INC2 GTH2k ,&loop JCN
	POP2 POP2
	( variable )
	STH2r
		DUP2 ;is-opcode JSR2 ,&on-opcode JCN
		DUP2 ;sihx JSR2 ,&on-hex JCN
	( error )
	POP2 ;runes/err

JMP2r
	&on-runic NIP2 POP2r JMP2r
	&on-opcode POP2 ;runes/opc JMP2r
	&on-hex POP2 ;runes/hex JMP2r

( helpers )

@print-symbols ( -- )

	LIT '- #18 DEOk DEOk DEO #0a18 DEO
	;syms
	&while
		LDA2k ;print JSR2 #2018 DEO
		INC2 INC2 DUP2 ;pstr JSR2 #0a18 DEO
		;scap JSR2
		INC2 LDAk ,&while JCN
	POP2

JMP2r

@create-label ( name* -- )

	( check duplicate )
	DUP2 ;find-label JSR2 #ffff EQU2 ,&unique JCN
		( ERROR: Duplicate )
		&unique
	( write ref )
	.p/ptr LDZ2 ;syms .sym/ptr LDZ2 STH2k ADD2 STA2
	INC2r INC2r
	( write string )
	DUP2 ;syms STH2kr ADD2 ;scpy JSR2
	;slen JSR2 STH2 ADD2r INC2r STH2r .sym/ptr STZ2

JMP2r

@make-sublabel ( name* -- sublabel* )

	;buf STH2k #0030 ;mclr JSR2
	;scope STH2kr ;scpy JSR2
	LIT '/ STH2kr ;sput JSR2
	STH2kr ;scat JSR2 STH2r

JMP2r

@find-label ( name* -- addr/ffff* )

	STH2
	;syms
	&while
		INC2k INC2 STH2kr ;scmp JSR2 ,&on-found JCN
		( go eol ) INC2 INC2 ;scap JSR2 INC2 INC2k INC2 LDA ,&while JCN
	POP2
	POP2r
	#ffff

JMP2r
	&on-found POP2r JMP2r

@set-scope ( token* -- name* )

	;scope STH2k #0030 ;mclr JSR2 DUP2 STH2r
	;scpy JSR2

JMP2r

@write-litbyte ( byte -- )

	( LITk ) #80 SWP ,write-short JMP

@write-litshort ( short* -- )

	( LIT2k ) #a0 ,write-byte JSR

@write-short ( short -- )

	SWP ,write-byte JSR

@write-byte ( byte -- )

	,&b STR ;&b .File2/write DEO2
	.p/ptr LDZ2k INC2 ROT STZ2

JMP2r
	&b $1

( operations )

@do-padabs ( token* -- )

	INC2 DUP2 ;sihx JSR2 ,&valid JCN
		;do-err JMP2
		&valid
	;shex JSR2 .p/ptr STZ2

JMP2r

@do-padrel ( token* -- )

	INC2 DUP2 ;sihx JSR2 ,&valid JCN
		;do-err JMP2
		&valid
	;shex JSR2 .p/ptr LDZ2 ADD2 .p/ptr STZ2

JMP2r

@do-labtop ( token* -- )

	INC2 ;set-scope JSR2 ;create-label JSR2

JMP2r

@do-labsub ( token* -- )

	INC2 ;make-sublabel JSR2 ;create-label JSR2

JMP2r

@do-rawchr ( token* -- )

	INC2 LDA ;write-byte JSR2

JMP2r

@do-rawtxt ( token* -- )

	&w LDAk ;write-byte JSR2 INC2 LDAk ,&w JCN POP2

JMP2r

@do-lithex ( token* -- )

	INC2 DUP2 ;sihx JSR2 ,&valid JCN
		;do-err JMP2
		&valid
	DUP2 ;slen JSR2 #0004 EQU2 ,&short JCN
	DUP2 ;slen JSR2 #0002 EQU2 ,&byte JCN
	;do-err JMP2

JMP2r
	&short ;shex JSR2 ;write-litshort JMP2
	&byte ;shex JSR2 NIP ;write-litbyte JMP2

@do-refzep ( token* -- )

	;pstr JSR2 #0a18 DEO

JMP2r

@do-refrel ( token* -- )

	;pstr JSR2 #0a18 DEO

JMP2r


@do-refabs ( token* -- )

	;pstr JSR2 #0a18 DEO

JMP2r

@do-refraw ( token* -- )

	;pstr JSR2 #0a18 DEO

JMP2r

@do-something ( token* -- )


	POP2
JMP2r

@do-opc ( token* -- )

	;find-opcode JSR2 ;write-byte JMP2

JMP2r

@do-hex ( token* -- )

	POP2

JMP2r

@do-err ( token* -- )

	;&error ;pstr JSR2 ;pstr JSR2
	#010f DEO

BRK
	&error "Error: 20 $1

@is-opcode ( string* -- flag )

	DUP2 ;opcodes/brk ,scmp3 JSR ,find-opcode/on-brk JCN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&loop
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr ,scmp3 JSR ,&on-found JCN
		INC GTHk ,&loop JCN
	POP2 POP2r #00

JMP2r
	&on-found
		NIP ( LITk ) DUP #00 EQU #70 SFT ADD
		STH2r INC2 INC2 INC2 ,find-mode JSR ADD JMP2r
	&on-brk POP2 #01 JMP2r

@find-mode ( mode* -- byte )

	LITr 00
	&while
		LDAk LIT '2 EQU #50 SFT STH ADDr
		LDAk LIT 'r EQU #60 SFT STH ADDr
		LDAk LIT 'k EQU #70 SFT STH ADDr
		INC2 LDAk ,&while JCN
	POP2 STHr

JMP2r

@scmp3 ( a[3]* b[3]* -- flag )

	LDA2k STH2 INC2 INC2 SWP2
	LDA2k STH2 INC2 INC2 EQU2r
	LDA STH LDA STH EQUr
	ANDr STHr

JMP2r

@runes
	'| :do-padabs '$ :do-padrel
	'@ :do-labtop '& :do-labsub
	'" :do-rawtxt '' :do-rawchr
	'. :do-refzep ', :do-refrel
	'; :do-refabs ': :do-refraw
	'# :do-lithex
	&err
	00 :do-err
	&opc
	00 :do-opc
	&hex
	00 :do-hex

@opcodes
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK

@pstr ( str* -- ) &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@scap ( str* -- end* ) LDAk #00 NEQ JMP JMP2r &w INC2 LDAk ,&w JCN JMP2r
@spop ( str* -- ) LDAk ,&n JCN POP2 JMP2r &n ,scap JSR #0001 SUB2 #00 ROT ROT STA JMP2r
@sput ( chr str* -- ) ,scap JSR INC2k #00 ROT ROT STA STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scat ( src* dst* -- ) ,scap JSR
@scpy ( src* dst* -- ) STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@mclr ( src* len* -- ) OVR2 ADD2 SWP2 &l STH2k #00 STH2r STA INC2 GTH2k ,&l JCN POP2 POP2 JMP2r
@mcpy ( src* dst* len* -- ) SWP2 STH2 OVR2 ADD2 SWP2 &loop LDAk STH2kr STA INC2r INC2 GTH2k ,&loop JCN POP2 POP2 POP2r JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r

@shex ( str* -- short* )

	LIT2r 0000
	&while
		LITr 40 SFT2r
		LITr 00
		LDAk ,chex JSR STH ADD2r
		INC2 LDAk ,&while JCN
	POP2 STH2r

JMP2r

@sihx ( str* -- flag )

	&while
		LDAk ,chex JSR #ff NEQ ,&valid JCN
			POP2 #00 JMP2r &valid
		INC2 LDAk ,&while JCN
	POP2
	#01

JMP2r

@chex ( char -- value/ff )

	DUP #2f GTH OVR #3a LTH AND ,&number JCN
	DUP #60 GTH OVR #67 LTH AND ,&lc JCN
		POP #ff

JMP2r
	&number #30 SUB JMP2r
	&lc #57 SUB JMP2r

@print ( short* -- )

	SWP ,&byte JSR
	&byte ( byte -- ) DUP #04 SFT ,&char JSR
	&char ( char -- ) #0f AND DUP #09 GTH #27 MUL ADD #30 ADD #18 DEO

JMP2r

@dst $40

@syms ( addr*, text, 00 )
