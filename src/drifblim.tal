( Usage: uxncli driflim.rom src.tal dst.rom )

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &err $1
|a0 @File1 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|b0 @File2 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@src $30
	@dst $30
	@run $1
	@size $2

|0100 ( -> )

	( project )
	;dict/drifblim .File1/name DEO2
	#0061 .File1/length DEO2
	#0000 .File1/read DEO2
	.File1/success DEI2 ORA ,on-ready JCN

	( interactive )
	;await-src .Console/vector DEO2 ;dict/input ;pstr JSR2

BRK

@await-src ( -> ) .Console/read DEI .src ;skey JSR2 ,ready-dst JCN BRK
@ready-dst ( -> ) ;await-dst .Console/vector DEO2 ;dict/output ;pstr JSR2 BRK
@await-dst ( -> ) .Console/read DEI .dst ;skey JSR2 ,on-ready JCN BRK

@on-ready ( -> )

	#0a18 DEO

	( pass1 ) ,assemble-top JSR

	( setup )
	;pass2/err ;tokenize/to STA2
	;pass2 ;tokenize/from STA2
	#00 ;write-byte/mock STA
	.size LDZ2 ;write-byte/bound STA2

	( prepare output )
	;dst .File2/name DEO2
	#01 .File2/delete DEO
	#0001 .File2/length DEO2

	( pass2 ) ,assemble-top JSR
	( symbols ) ;summary JSR2
	( auto ) .run LDZ ,&run JCN
	( halt ) #010f DEO

BRK

&run ( -> )

	;dst .File1/name DEO2
	#fe00 .File1/length DEO2
	;loader-rom #ffd5 #002a ;mcpy JSR2
	#ffd5 ( .. )

JMP2

(
@|stream )

@assemble-top ( file* -- )

	#0000
		DUP2 .size STZ2
		;write-byte/ptr STA2
	;src

@assemble ( file* -- )

	( stream )
	DUP2 .File1/name DEO2
	#0001 .File1/length DEO2
	&s
		;&c .File1/read DEO2
		.File1/success DEI2 #0000 EQU2 ,&eof JCN
		[ LIT &c $1 ] ,stream JSR
		,&s JMP &eof
	( check if file exists )
	,&c LDR #00 EQU ,&empty JCN
	POP2

JMP2r
	&empty ;err/source ;crash JMP2

@stream ( char -- )

	#20 GTHk NIP ,&append JCN POP
	;token LDAk ,&run JCN
	( skip empty ) POP2

JMP2r
	&run ( token* -- )
		DUP2 ,read-token JSR
		;sclr JMP2
	&append ( char -- )
		;token
			DUP2 ;slen JSR2 #0018 EQU2 ,&overflow JCN
			;sput JMP2
	&overflow ( char token* -- )
		ROT POP ;err/token ;crash JMP2

(
@|token )

@read-token ( token* -- )

	LDAk LIT "( EQU ,&on-parens JCN
	LDAk LIT ") EQU ,&on-parens JCN
	[ LIT &sleep $1 ] ,&on-sleep JCN
	DUP2 ,tokenize JSR
		INC2 LDA2 ( .. )

JMP2
	&on-parens LDA LIT "( EQU ,&sleep STR JMP2r
	&on-sleep POP2 JMP2r

@tokenize ( token* -- type* )

	STH2
	( runes )
	[ LIT2 &to =pass1/err ] [ LIT2 &from =pass1 ]
	&l
		LDAk LDAkr STHr EQU ,&on-runic JCN
		INC2 INC2 INC2 GTH2k ,&l JCN
	POP2 POP2
	( variable )
	STH2r
		DUP2 ;is-opcode JSR2 ,&on-opcode JCN
		DUP2 ;is-hex JSR2 ,&on-rawhex JCN
	( error )
	POP2 ;pass1/err

JMP2r
	&on-runic NIP2 POP2r JMP2r
	&on-opcode POP2 ;pass1/opcode JMP2r
	&on-rawhex POP2 ;pass1/rawhex JMP2r

(
@|operations )

@do-inc ( t* -- ) INC2k ;incsrc STH2k ;scpy JSR2 ;sclr JSR2 STH2r ;assemble JMP2
@do-ignore ( t* -- ) POP2 JMP2r
@do-padabs ( t* -- ) INC2 ;shex JSR2 ;write-byte/ptr LDA2 LTH2k ,&rev JCN SUB2 ;fill JMP2 &rev POP2 ;write-byte/ptr STA2 JMP2r
@do-padrel ( t* -- ) INC2 ;shex JSR2 ;fill JMP2
@do-labtop ( t* -- ) INC2 ;set-scope JSR2 ;create-label JMP2
@do-labsub ( t* -- ) INC2 ;make-sublabel JSR2 ;create-label JMP2
@do-rawtxt ( t* -- ) INC2 &w LDAk ;write-byte JSR2 INC2 LDAk ,&w JCN POP2 JMP2r
@do-lithex ( t* -- ) INC2 ;write-lithex JMP2
@do-opcode ( t* -- ) ;find-opcode JSR2 ;write-byte JMP2
@do-rawhex ( t* -- ) ;write-rawhex JMP2
@do-errors ( t* -- ) ;err/token ;crash JMP2
@do-neulzep ( t* -- ) POP2 #ff ;write-litbyte JMP2
@do-neurzep ( t* -- ) POP2 #ff ;write-byte JMP2
@do-neulabs ( t* -- ) POP2 #ffff ;write-litshort JMP2
@do-neurabs ( t* -- ) POP2 #ffff ;write-short JMP2
@do-neutop ( t* -- ) INC2 ,set-scope JSR POP2 JMP2r
@do-reflrel ( t* -- ) INC2 ,get-ref JSR ,get-rel JSR ;write-litbyte JMP2
@do-refrrel ( t* -- ) INC2 ,get-ref JSR ,get-rel JSR INC ;write-byte JMP2
@do-reflzep ( t* -- ) INC2 ,get-ref JSR LDA2 NIP ;write-litbyte JMP2
@do-refrzep ( t* -- ) INC2 ,get-ref JSR LDA2 NIP ;write-byte JMP2
@do-reflabs ( t* -- ) INC2 ,get-ref JSR LDA2 ;write-litshort JMP2
@do-refrabs ( t* -- ) INC2 ,get-ref JSR LDA2 ;write-short JMP2

(
@|helpers )

@set-scope ( t* -- name* )

	;scope OVR2 SWP2 ;scpy ( .. )

JMP2

@get-rel ( label* -- distance )

	LDA2k ;write-byte/ptr LDA2 SUB2 #0003 SUB2
	DUP2 #0080 ADD2 POP ,&fail JCN
	NIP2 NIP

JMP2r
	&fail POP2 INC2 INC2 INC2 ;err/distance ;crash JMP2

@get-ref ( token* -- <label*> )

	LDAk LIT "& NEQ ,&no-sub JCN
		INC2 ;make-sublabel JSR2
		&no-sub
	;find-label JSR2
		INC2k ORA ,&found JCN
			POP2 ;err/reference ;crash JMP2
			&found

	( count ) INC2k INC2 LDAk INC ROT ROT STA

JMP2r

@create-label ( name* -- )

	( check duplicate ) DUP2 ;find-label JSR2 INC2 ORA ,&not-unique JCN
	( save addr ) ;write-byte/ptr LDA2 [ LIT2 &ptr =symbols ] STH2k STA2
	( move ) INC2r INC2r INC2r
	( save name ) DUP2 STH2kr ;scpy JSR2
	( move ) ;slen JSR2 STH2r ADD2 INC2 ,&ptr STR2
	( stats ) [ LIT2 &count $2 ] INC2 ,&count STR2

JMP2r
	&not-unique ;err/duplicate ;crash JMP2

@make-sublabel ( name* -- sublabel* )

	;scope ;buf STH2k ;scpy JSR2
	LIT "/ STH2kr ;sput JSR2
	STH2kr ;scat JSR2
	STH2r

JMP2r

@find-label ( name* -- <addr*> )

	STH2
	;symbols
	&w
		INC2 INC2 INC2 DUP2 STH2kr ;scmp JSR2 ,&found JCN
		;scap JSR2 INC2 INC2k INC2 INC2 LDA ,&w JCN
	POP2
	POP2r
	#ffff

JMP2r
	&found #0003 SUB2 POP2r JMP2r

@write-lithex ( str* -- )

	DUP2 ;is-hex JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-litshort JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-litbyte JMP
		&no-byte
	&invalid
	;err/number ;crash ( .. )

JMP2

@write-rawhex ( str* -- )

	DUP2 ;is-hex JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-short JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-byte JMP
		&no-byte
	&invalid
	;err/number ;crash ( .. )

JMP2

@write-litbyte ( byte -- )

	( LITk ) #80 SWP ,write-short JMP

@write-litshort ( short* -- )

	( LIT2k ) #a0 ,write-byte JSR

@write-short ( short -- )

	SWP ,write-byte JSR

@write-byte ( byte -- )

	,&byte STR
	[ LIT2 &ptr $2 ]
	[ LIT &mock 01 ] ,&no-w JCN
	DUP2 #0100 LTH2 ,&no-w JCN
	DUP2 [ LIT2 &bound $2 ] GTH2 ,&no-w JCN
		;&byte .File2/write DEO2
		&no-w
	INC2 
		DUP2 ,&ptr STR2
		[ LIT &byte $1 ] ,&no-null JCN
	POP2

JMP2r
	&no-null .size STZ2 JMP2r

@fill ( length* -- )

	#0000 EQU2k ,&skip JCN
	&l
		#00 ,write-byte JSR
		INC2 GTH2k ,&l JCN
		&skip
	POP2 POP2

JMP2r

@is-opcode ( string* -- flag )

	DUP2 ;opcodes/brk ;scmp3 JSR2 ,find-opcode/on-brk JCN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&l
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr ;scmp3 JSR2 ,&on-found JCN
		INC GTHk ,&l JCN
	POP2 POP2r #00

JMP2r
	&on-found
		NIP ( LITk ) DUP #00 EQU #70 SFT ADD
		STH2r INC2 INC2 INC2 ,find-modes JSR ADD JMP2r
	&on-brk POP2 #01 JMP2r

@find-modes ( mode* -- byte )

	LITr 00
	&w
		LDAk #20
		OVR LIT "2 EQU ,&end JCN DUP ADD
		OVR LIT "r EQU ,&end JCN DUP ADD
		OVR LIT "k EQU ,&end JCN DUP ADD
		OVR #21 LTH ,&end JCN
			;token ;err/mode ;crash JMP2
		&end NIP STH ORAr
		INC2 LDAk ,&w JCN
	POP2 STHr

JMP2r

@scmp3 ( a* b* -- flag )

	LDA2k ROT2 LDA2k ROT2 EQU2 STH
	INC2 LDA2 SWP2 INC2 LDA2 EQU2 STHr
	AND

JMP2r

(
@|extras )

@summary ( -- )

	;symbols
	&w
		( ignore uppercased device labels )
		INC2k INC2 INC2 LDA DUP #40 GTH SWP #5b LTH AND ,&used JCN
		INC2k INC2 LDA ,&used JCN
			;dict/unused ;pstr JSR2
			INC2 INC2 INC2 DUP2 ;pstr JSR2 #0a18 DEO
			&used
		;scap JSR2 INC2 INC2k INC2 INC2 LDA ,&w JCN
	POP2

	( result )
	;dict/assembled ;pstr JSR2

	;src ;pstr JSR2
	;dict/spacer ;pstr JSR2
	;dst ;pstr JSR2

	;dict/in ;pstr JSR2
	.size LDZ2 #0100 SUB2 ;pdec JSR2
	;dict/bytes ;pstr JSR2
	LIT "( #18 DEO
	;create-label/count LDA2 ;pdec JSR2
	;dict/labels ;pstr JSR2
	LIT ") #18 DEO
	#0a18 DEO

JMP2r

@crash ( id* name* -- )

	;err ;perr JSR2
	;perr JSR2
	LIT ": #19 DEO
	#2019 DEO
	;perr JSR2
	#0a19 DEO
	#010f DEO

BRK

(
@|stdlib )

@pstr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@perr ( src* str* -- ) &w LDAk #19 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@scap ( str* -- end* ) LDAk ,&w JCN JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR INC2k #00 ROT ROT STA STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scat ( src* dst* -- ) ,scap JSR
@scpy ( src* dst* -- ) OVR2 LDA ,&e JCN POP2 POP2 JMP2r &e STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@sclr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w STH2k #00 STH2r STA INC2 LDAk ,&w JCN POP2 JMP2r
@skey ( key buf -- proc ) OVR #21 LTH ,&eval JCN #00 SWP ;sput JSR2 #00 JMP2r &eval POP2 #01 JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r
@mcpy ( src* dst* len* -- ) SWP2 STH2 OVR2 ADD2 SWP2 &loop LDAk STH2kr STA INC2r INC2 GTH2k ,&loop JCN POP2 POP2 POP2r JMP2r
@chex ( c -- val|ff ) LIT "0 SUB DUP #09 GTH JMP JMP2r #27 SUB DUP #0f GTH JMP JMP2r POP #ff JMP2r

@shex ( str* -- val* )

	LIT2r 0000
	&w
		LITr 40 SFT2r
		LITr 00 LDAk ,chex JSR STH ADD2r
		INC2 LDAk ,&w JCN
	POP2 STH2r

JMP2r

@is-hex ( str* -- flag )

	&w
		LDAk ,chex JSR INC ,&valid JCN
			POP2 #00 JMP2r &valid
		INC2 LDAk ,&w JCN
	POP2
	#01

JMP2r

@pdec ( short* -- )

	#00 ,&z STR
	#2710 ,&parse JSR
	#03e8 ,&parse JSR
	#0064 ,&parse JSR
	#000a ,&parse JSR
	NIP #30 ADD #18 DEO

JMP2r
	&parse
		DIV2k DUPk [ LIT &z $1 ] EQU ,&skip JCN
		DUP #30 ADD #18 DEO #ff ,&z STR
		&skip POP MUL2 SUB2
	JMP2r

(
@|tables )

@pass1
	"| =do-padabs "$ =do-padrel
	"@ =do-labtop "& =do-labsub
	", =do-neulzep "_ =do-neulzep
	". =do-neulzep "- =do-neurzep
	"; =do-neulabs "= =do-neurabs
	"[ =do-ignore "] =do-ignore
	"# =do-lithex "" =do-rawtxt
	"~ =do-inc
	&err
	00 =do-errors
	&opcode
	00 =do-opcode
	&rawhex
	00 =do-rawhex

@pass2
	"| =do-padabs "$ =do-padrel
	"@ =do-neutop "& =do-ignore
	", =do-reflrel "_ =do-refrrel
	". =do-reflzep "- =do-refrzep
	"; =do-reflabs "= =do-refrabs
	"[ =do-ignore "] =do-ignore
	"# =do-lithex "" =do-rawtxt
	"~ =do-inc
	&err

@opcodes
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK

@dict
	( io )
	&input "Input(.tal): 20 $1
	&output "Output(.rom): 20 $1
	&drifblim ".drifblim $1
	( debug )
	&assembled "Assembled 20 $1
	&spacer 20 "-> 20 $1
	&in 20 "in 20 $1
	&bytes 20 "bytes $1
	&labels 20 "labels $1
	&unused "-- 20 "Unused 20 "label: 20 $1

@err
	"!! 20 "Error 20 $1
	&duplicate "Duplicate  $1
	&token "Token $1
	&number "Number $1
	&reference "Reference $1
	&source "Source $1
	&mode "Mode $1
	&distance "Distance $1

@loader-rom
	8000 8000 0711 0106 80f7 0d02 a001 00af
	80ac 37a0 ffd5 80a2 36ef 3826 8000 0505
	1521 aa80 f50d 2222 6f2c

(
@|buffers )

@incsrc $30
@buf $30
@scope $20
@token $20

(
@|memory )

@symbols ( addr*, refs, text, 00 )
