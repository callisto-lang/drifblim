( Usage: uxncli driflim.rom src.tal dst.rom )

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &err $1
|a0 @File1 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|b0 @File2 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@src $30
	@dst $30
	@res
		@buf $30
		@scope $30
		@token $30
		@size $2
		@prg-ptr $2

|0100 ( -> ) ;await-src .Console/vector DEO2 ;dict/input ;pstr JSR2 BRK
@await-src ( -> ) .Console/read DEI .src ;skey JSR2 ,ready-dst JCN BRK
@ready-dst ( -> ) ;await-dst .Console/vector DEO2 ;dict/output ;pstr JSR2 BRK
@await-dst ( -> ) .Console/read DEI .dst ;skey JSR2 ,on-ready JCN BRK

@on-ready ( -> )

	#0a18 DEO

	( pass1 ) ;src ,assemble-top JSR

	( setup )
	;pass2/err ;tokenize/to STA2
	;pass2 ;tokenize/from STA2
	#00 ;write-byte/mock STA
	.size LDZ2 ;write-byte/bound STA2
	;dst .File2/name DEO2
	#0001 .File2/length DEO2

	( pass2 ) ;src ,assemble-top JSR

	( print symbols )
	;print-summary JSR2

	( halt )
	#0101 #0e DEO2

BRK

(
@|main )

@assemble-top ( file* -- )

	;res #00a0 ;mclr JSR2

@assemble ( file* -- )

	( stream )
	DUP2 .File1/name DEO2
	#0001 .File1/length DEO2
	&s
		;&c .File1/read DEO2
		.File1/success DEI2 #0000 EQU2 ,&eof JCN
		[ LIT &c $1 ] ,walk JSR
		,&s JMP &eof

	( check if file exists )
	,&c LDR #00 EQU ,&empty JCN
	POP2

JMP2r
	&empty ;dict/source ;crash JMP2

@walk ( char -- )

	#20 GTHk NIP ,&append JCN POP
	;token DUP2 ;slen JSR2 ORA ,&run JCN
	( skip empty ) POP2

JMP2r
	&run DUP2 ,walk-token JSR #0030 ;mclr JMP2
	&append ;token ;sput JMP2

@walk-token ( token* -- )

	LDAk LIT "( EQU ,&on-parens JCN
	LDAk LIT ") EQU ,&on-parens JCN
	[ LIT &sleep $1 ] ,&on-sleep JCN
	( parse ) DUP2 ,tokenize JSR INC2 LDA2 ( .. )

JMP2
	&on-parens LDA #29 SUB ,&sleep STR JMP2r
	&on-sleep POP2 JMP2r

@tokenize ( token* -- type* )

	STH2
	( runes )
	[ LIT2 &to :pass1/err ] [ LIT2 &from :pass1 ]
	&l
		LDAk STH2kr LDA EQU ,&on-runic JCN
		INC2 INC2 INC2 GTH2k ,&l JCN
	POP2 POP2
	( variable )
	STH2r
		DUP2 ;is-opcode JSR2 ,&on-opcode JCN
		DUP2 ;sihx JSR2 ,&on-rawhex JCN
	( error )
	POP2 ;pass1/err

JMP2r
	&on-runic NIP2 POP2r JMP2r
	&on-opcode POP2 ;pass1/opcode JMP2r
	&on-rawhex POP2 ;pass1/rawhex JMP2r

(
@|operations )

@do-inc ( t* -- ) INC2k ;incsrc STH2k ;scpy JSR2 #0030 ;mclr JSR2 STH2r ;assemble JMP2
@do-ignore ( t* -- ) POP2 JMP2r
@do-padabs ( t* -- ) INC2 ;shex JSR2 .prg-ptr LDZ2 LTH2k ,&rev JCN SUB2 ;fill JMP2 &rev POP2 .prg-ptr STZ2 JMP2r
@do-padrel ( t* -- ) INC2 ;shex JSR2 ;fill JMP2
@do-labtop ( t* -- ) INC2 ;set-scope JSR2 ;create-label JMP2
@do-labsub ( t* -- ) INC2 ;make-sublabel JSR2 ;create-label JMP2
@do-rawtxt ( t* -- ) INC2 &w LDAk ;write-byte JSR2 INC2 LDAk ,&w JCN POP2 JMP2r
@do-lithex ( t* -- ) INC2 ;write-lithex JMP2
@do-opcode ( t* -- ) ;find-opcode JSR2 ;write-byte JMP2
@do-rawhex ( t* -- ) ;write-rawhex JMP2
@do-errors ( t* -- ) ;dict/token ;crash JMP2
@do-neuzep ( t* -- ) POP2 #ff ;write-litbyte JMP2
@do-neuabs ( t* -- ) POP2 #ffff ;write-litshort JMP2
@do-neuraw ( t* -- ) POP2 #ffff ;write-short JMP2
@do-neutop ( t* -- ) INC2 ;set-scope JSR2 POP2 JMP2r
@do-refzep ( t* -- ) INC2 ,get-ref JSR LDA2 NIP ;write-litbyte JMP2
@do-refrel ( t* -- ) INC2 ,get-ref JSR ,get-rel JSR ;write-litbyte JMP2
@do-refabs ( t* -- ) INC2 ,get-ref JSR LDA2 ;write-litshort JMP2
@do-refraw ( t* -- ) INC2 ,get-ref JSR LDA2 ;write-short JMP2

(
@|helpers )

@set-scope ( t* -- name* )

	;scope STH2k #0030 ;mclr JSR2
		DUP2 STH2r ;scpy ( .. )

JMP2

@get-rel ( label* -- distance )

	LDA2k .prg-ptr LDZ2 SUB2 #0003 SUB2
	DUP2 #0080 ADD2 POP ,&fail JCN
	NIP2 NIP

JMP2r
	&fail POP2 INC2 INC2 INC2 ;dict/far ;crash JMP2

@get-ref ( token* -- <label*> )

	LDAk LIT "& NEQ ,&no-sub JCN
		INC2 ;make-sublabel JSR2
		&no-sub
	;find-label JSR2
	DUP2 #ffff EQU2 ,&fail JCN

	( count ) INC2k INC2 LDAk INC ROT ROT STA

JMP2r
	&fail POP2 ;dict/label ;crash JMP2

@create-label ( name* -- )

	( check duplicate )
	DUP2 ;find-label JSR2 #ffff EQU2 ,&unique JCN
		;dict/duplicate ;crash JMP2
		&unique
	( save addr ) .prg-ptr LDZ2 [ LIT2 &ptr :symbols ] STH2k STA2
	( move ) INC2r INC2r INC2r
	( save name ) DUP2 STH2kr ;scpy JSR2
	( move ) ;slen JSR2 STH2r ADD2 INC2 ,&ptr STR2
	( stats ) [ LIT2 &count $2 ] INC2 ,&count STR2

JMP2r

@make-sublabel ( name* -- sublabel* )

	;buf STH2k #0030 ;mclr JSR2
	;scope STH2kr ;scpy JSR2
	LIT "/ STH2kr ;sput JSR2
	STH2kr ;scat JSR2
	STH2r

JMP2r

@find-label ( name* -- <addr*> )

	STH2
	;symbols
	&w
		INC2 INC2 INC2 DUP2 STH2kr ;scmp JSR2 ,&found JCN
		;scap JSR2 INC2 INC2k INC2 INC2 LDA ,&w JCN
	POP2
	POP2r
	#ffff

JMP2r
	&found #0003 SUB2 POP2r JMP2r

@write-lithex ( str* -- )

	DUP2 ;sihx JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-litshort JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-litbyte JMP
		&no-byte
	&invalid
	;dict/number ;crash ( .. )

JMP2

@write-rawhex ( str* -- )

	DUP2 ;sihx JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-short JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-byte JMP
		&no-byte
	&invalid
	;dict/number ;crash ( .. )

JMP2

@write-litbyte ( byte -- )

	( LITk ) #80 SWP ,write-short JMP

@write-litshort ( short* -- )

	( LIT2k ) #a0 ,write-byte JSR

@write-short ( short -- )

	SWP ,write-byte JSR

@write-byte ( byte -- )

	DUP ,&b STR
	.prg-ptr LDZ2
	[ LIT &mock 01 ] ,&no-w JCN
	DUP2 #0100 LTH2 ,&no-w JCN
	DUP2 [ LIT2 &bound $2 ] GTH2 ,&no-w JCN
		;&b .File2/write DEO2
		&no-w
	INC2 .prg-ptr STZ2
	,&no-null JCN

JMP2r
	&no-null .prg-ptr LDZ2 .size STZ2 JMP2r
	&b $1

@fill ( length* -- )

	#0000 EQU2k ,&skip JCN
	&l
		#00 ,write-byte JSR
		INC2 GTH2k ,&l JCN
	POP2 POP2

JMP2r
	&skip POP2 POP2 JMP2r

@is-opcode ( string* -- flag )

	DUP2 ;opcodes/brk ,scmp3 JSR ,find-opcode/on-brk JCN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&l
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr ,scmp3 JSR ,&on-found JCN
		INC GTHk ,&l JCN
	POP2 POP2r #00

JMP2r
	&on-found
		NIP ( LITk ) DUP #00 EQU #70 SFT ADD
		STH2r INC2 INC2 INC2 ,find-mode JSR ADD JMP2r
	&on-brk POP2 #01 JMP2r

@find-mode ( mode* -- byte )

	LITr 00
	&w
		LDAk LIT "2 EQU #50 SFT STH ADDr
		LDAk LIT "r EQU #60 SFT STH ADDr
		LDAk LIT "k EQU #70 SFT STH ADDr
		INC2 LDAk ,&w JCN
	POP2 STHr

JMP2r

@scmp3 ( a[3]* b[3]* -- flag )

	LDA2k STH2 INC2 INC2 SWP2
	LDA2k STH2 INC2 INC2 EQU2r
	LDA STH LDA STH EQUr
	ANDr STHr

JMP2r

@print-summary ( -- )

	;symbols
	&w
		( ignore uppercased device labels )
		INC2k INC2 INC2 LDA DUP #40 GTH SWP #5b LTH AND ,&used JCN
		INC2k INC2 LDA ,&used JCN
			;dict/unused ;pstr JSR2
			INC2 INC2 INC2 DUP2 ;pstr JSR2 #0a18 DEO
			&used
		;scap JSR2 INC2 INC2k INC2 INC2 LDA ,&w JCN
	POP2

	( result )
	;dict/assembled ;pstr JSR2

	;src ;pstr JSR2
	;dict/spacer ;pstr JSR2
	;dst ;pstr JSR2

	;dict/in ;pstr JSR2
	.size LDZ2 #0100 SUB2 ;pdec JSR2
	;dict/bytes ;pstr JSR2
	LIT "( #18 DEO
	;create-label/count LDA2 ;pdec JSR2
	;dict/labels ;pstr JSR2
	LIT ") #18 DEO
	#0a18 DEO

JMP2r

@crash ( id* name* -- )

	;dict/err ;perr JSR2
	;perr JSR2
	LIT ": #19 DEO
	#2019 DEO
	;perr JSR2
	#0a19 DEO
	#010f DEO

BRK

(
@|stdlib )

@pstr ( str* -- ) &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@perr ( src* str* -- ) &w LDAk #19 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@scap ( str* -- end* ) LDAk #00 NEQ JMP JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR INC2k #00 ROT ROT STA STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scat ( src* dst* -- ) ,scap JSR
@scpy ( src* dst* -- ) STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@skey ( key buf -- proc ) OVR #21 LTH ,&eval JCN #00 SWP ;sput JSR2 #00 JMP2r &eval POP2 #01 JMP2r
@mclr ( src* len2* -- ) OVR2 ADD2 SWP2 &l STH2k #0000 STH2r STA2 INC2 INC2 GTH2k ,&l JCN POP2 POP2 JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r

@shex ( str* -- val* )

	LIT2r 0000
	&w
		LITr 40 SFT2r
		LITr 00 LDAk ,chex JSR STH ADD2r
		INC2 LDAk ,&w JCN
	POP2 STH2r

JMP2r

@sihx ( str* -- flag )

	&w
		LDAk ,chex JSR #ff NEQ ,&valid JCN
			POP2 #00 JMP2r &valid
		INC2 LDAk ,&w JCN
	POP2
	#01

JMP2r

@chex ( char -- <hex> )

	DUP #2f GTH OVR #3a LTH AND ,&n JCN
	DUP #60 GTH OVR #67 LTH AND ,&l JCN
		POP #ff

JMP2r
	&n #30 SUB JMP2r
	&l #57 SUB JMP2r

@pdec ( short* -- )

	#00 ,&z STR
	#2710 ,&parse JSR
	#03e8 ,&parse JSR
	#0064 ,&parse JSR
	#000a ,&parse JSR
	NIP #30 ADD #18 DEO

JMP2r
	&parse
		DIV2k DUPk [ LIT &z $1 ] EQU ,&skip JCN
		DUP #30 ADD #18 DEO #ff ,&z STR
		&skip POP MUL2 SUB2
	JMP2r

(
@|assets )

@pass1
	"| :do-padabs "$ :do-padrel
	"@ :do-labtop "& :do-labsub
	". :do-neuzep ", :do-neuzep
	"; :do-neuabs ": :do-neuraw
	"[ :do-ignore "] :do-ignore
	"# :do-lithex "" :do-rawtxt
	"~ :do-inc
	&err
	00 :do-errors
	&opcode
	00 :do-opcode
	&rawhex
	00 :do-rawhex

@pass2
	"| :do-padabs "$ :do-padrel
	"@ :do-neutop "& :do-ignore
	". :do-refzep ", :do-refrel
	"; :do-refabs ": :do-refraw
	"[ :do-ignore "] :do-ignore
	"# :do-lithex "" :do-rawtxt
	"~ :do-inc
	&err

@opcodes
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK

@dict
	( io )
	&input "Input(.tal): 20 $1
	&output "Output(.rom): 20 $1
	( debug )
	&assembled "Assembled 20 $1
	&spacer 20 "-> 20 $1
	&in 20 "in 20 $1
	&bytes 20 "bytes $1
	&labels 20 "labels $1
	&unused "-- 20 "Unused 20 "label: 20 $1
	( errors )
	&err "!! 20 "Error 20 $1
	&duplicate "Duplicate 20 "Label $1
	&token "Token $1
	&number "Number $1
	&label "Label $1
	&source "Source $1
	&far "Too 20 "Far $1

@incsrc $30

@symbols ( addr*, refs, text, 00 )
