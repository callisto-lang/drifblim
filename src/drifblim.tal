( Usage: uxncli driflim.rom src/source.tal -> src/source.rom )

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &err $1
|a0 @File &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|b0 @File2 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@src $30
	@res
		@dst $30
		@buf $30
		@scope $30
		@token $30
		@p &ptr $2
		@sym &ptr $2

|0100

	;on-console .Console/vector DEO2

BRK

@on-console ( -> )

	;src STH2

	( filepath )
	.Console/read DEI
	DUP #20 LTH OVR #7f GTH ORA ,&end JCN
	STH2kr ;slen JSR2 #002f GTH2 ,&end JCN
		STH2r ;sput JSR2 BRK
		&end
	POP

	( pass1 )
	STH2kr ,assemble JSR

	( print symbols )
	;syms ;print-mem JSR2
	;print-symbols JSR2

	( pass2 )
	;pass2/err ;find-token/to STA2
	;pass2 ;find-token/from STA2
	STH2r ,assemble JSR


	( halt )
	#010e DEO
	#010f DEO

BRK

@assemble ( file* -- )

	;res #00d0 ;mclr JSR2
	;syms .sym/ptr STZ2

	( prepare output )
	DUP2 ;dst #0030 ;mcpy JSR2
	;&rom-ext ;dst ;scap JSR2 #0004 SUB2 ;scpy JSR2
	;dst .File2/name DEO2
	#0001 .File2/length DEO2

	( stream )
	.File/name DEO2
	#0001 .File/length DEO2
	&stream
		;&c .File/read DEO2
		.File/success DEI2 #0000 EQU2 ,&eof JCN
		[ LIT &c $1 ] ,walk JSR
		,&stream JMP &eof

JMP2r
	&rom-ext ".rom $1

@walk ( char -- )

	#20 GTHk NIP ,&append JCN POP
	;token DUP2 ;slen JSR2 ORA ,&run JCN
	( skip empty ) POP2

JMP2r
	&run DUP2 ,walk-token JSR #0030 ;mclr JMP2
	&append ;token ;sput JMP2

@walk-token ( token* -- )

	LDAk LIT '( EQU ,&on-parens JCN
	LDAk LIT ') EQU ,&on-parens JCN
	[ LIT &sleep $1 ] ,&on-sleep JCN

	( parse )
	DUP2 ,find-token JSR INC2 LDA2 ( .. )

JMP2

	&on-parens LDA #29 SUB ,&sleep STR JMP2r
	&on-sleep POP2 JMP2r

@find-token ( token* -- type* )

	STH2

	( runes )
	[ LIT2 &to :pass1/err ] [ LIT2 &from :pass1 ]
	&loop
		LDAk STH2kr LDA EQU ,&on-runic JCN
		INC2 INC2 INC2 GTH2k ,&loop JCN
	POP2 POP2

	( variable )
	STH2r
		DUP2 ;is-opcode JSR2 ,&on-opcode JCN
		DUP2 ;sihx JSR2 ,&on-rawhex JCN

	( error )
	POP2 ;pass1/err

JMP2r
	&on-runic NIP2 POP2r JMP2r
	&on-opcode POP2 ;pass1/opcode JMP2r
	&on-rawhex POP2 ;pass1/rawhex JMP2r

( helpers )

@create-label ( name* -- )

	( check duplicate )
	DUP2 ;find-label JSR2 #ffff EQU2 ,&unique JCN
		#1234 ;print JSR2 #0a18 DEO
		;errors/duplicate ;error JMP2
		&unique

	.p/ptr LDZ2 ;print JSR2 #2018 DEO
	.sym/ptr LDZ2 ;print JSR2 #2018 DEO
	DUP2 ;pstr JSR2 #2018 DEO
	DUP2 ;slen JSR2 ;print JSR2 #0a18 DEO

	( save ptr )
	.p/ptr LDZ2 .sym/ptr LDZ2 STA2

	( move )
	.sym/ptr LDZ2k INC2 INC2 ROT STZ2

	( save str )
	STH2k .sym/ptr LDZ2 ;scpy JSR2

	( move )
	.sym/ptr LDZ2k STH2r ;slen JSR2 ADD2 INC2 ROT STZ2

JMP2r

@make-sublabel ( name* -- sublabel* )

	;buf STH2k #0030 ;mclr JSR2
	;scope STH2kr ;scpy JSR2
	LIT '/ STH2kr ;sput JSR2
	STH2kr ;scat JSR2
	STH2r

JMP2r

@find-label ( name* -- addr*|ffff )

	STH2
	;syms
	&while
		INC2 INC2 DUP2 STH2kr ;scmp JSR2 ,&found JCN
		;scap JSR2 INC2 INC2k INC2 LDA ,&while JCN
	POP2
	POP2r
	#ffff

JMP2r
	&found #0002 SUB2 POP2r JMP2r

@set-scope ( t* -- name* ) ;scope STH2k #0030 ;mclr JSR2 DUP2 STH2r ;scpy ( .. ) JMP2

@write-lithex ( str* -- )

	DUP2 ;sihx JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-litshort JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-litbyte JMP
		&no-byte
	&invalid
	;errors/number ;error ( .. )

JMP2

@write-rawhex ( str* -- )

	DUP2 ;sihx JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-short JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write-byte JMP
		&no-byte
	&invalid
	;errors/number ;error ( .. )

JMP2

@write-litbyte ( byte -- )

	( LITk ) #80 SWP ,write-short JMP

@write-litshort ( short* -- )

	( LIT2k ) #a0 ,write-byte JSR

@write-short ( short -- )

	SWP ,write-byte JSR

@write-byte ( byte -- )

	,&b STR
	.p/ptr LDZ2 #0100 LTH2 ,&zp JCN
		;&b .File2/write DEO2
		&zp
	.p/ptr LDZ2k INC2 ROT STZ2

JMP2r
	&b $1

@fill ( length* -- )

	#0000 EQU2k ,&skip JCN
	&loop
		#00 ,write-byte JSR
		INC2 GTH2k ,&loop JCN
	POP2 POP2

JMP2r
	&skip POP2 POP2 JMP2r

( operations )

@do-padabs ( t* -- )

	INC2 ;shex JSR2 .p/ptr LDZ2
	LTH2k ,&backward JCN
	SUB2 ,fill JSR

JMP2r
	&backward POP2 .p/ptr STZ2 JMP2r

@do-padrel ( t* -- ) INC2 ;shex JSR2 ,fill JSR JMP2r
@do-labtop ( t* -- ) INC2 ;set-scope JSR2 ;create-label JMP2
@do-labsub ( t* -- ) INC2 ;make-sublabel JSR2 ;create-label JMP2
@do-rawchr ( t* -- ) INC2 LDA ;write-byte JMP2
@do-rawtxt ( t* -- ) INC2 &w LDAk ;write-byte JSR2 INC2 LDAk ,&w JCN POP2 JMP2r
@do-lithex ( t* -- ) INC2 ;write-lithex JMP2
@do-opcode ( t* -- ) ;find-opcode JSR2 ;write-byte JMP2
@do-rawhex ( t* -- ) ;write-rawhex JMP2
@do-errors ( t* -- ) ;errors/unknown ;error JMP2

@do-neuzep ( t* -- ) POP2 #ff ;write-litbyte JMP2
@do-neurel ( t* -- ) POP2 #ff ;write-litbyte JMP2
@do-neuabs ( t* -- ) POP2 #ffff ;write-litshort JMP2
@do-neuraw ( t* -- ) POP2 #ffff ;write-short JMP2
@do-neutop ( t* -- ) INC2 ;set-scope JSR2 POP2 JMP2r

@do-refzep ( t* -- ) INC2 ;get-ref JSR2 LDA2 NIP ;write-litbyte JMP2
@do-refrel ( t* -- ) INC2 ;get-ref JSR2 ;get-rel JSR2 ;write-litbyte JMP2
@do-refabs ( t* -- ) INC2 ;get-ref JSR2 LDA2 ;write-litshort JMP2
@do-refraw ( t* -- ) INC2 ;get-ref JSR2 LDA2 ;write-short JMP2

@get-rel ( label* -- distance )

	LDA2k .p/ptr LDZ2 SUB2 #0003 SUB2
	DUP2 #0080 ADD2 POP ,&fail JCN
	NIP2 NIP

JMP2r
	&fail POP2 INC2 INC2 ;errors/far ;error JMP2

@get-ref ( token* -- label*|ffff )

	LDAk LIT '& NEQ ,&no-sub JCN
		INC2 ;make-sublabel JSR2
		&no-sub
	;find-label JSR2
	DUP2 #ffff EQU2 ,&fail JCN

JMP2r
	&fail POP2 ;errors/label ;error JMP2

@do-ignore ( t* -- ) POP2 JMP2r

@is-opcode ( string* -- flag )

	DUP2 ;opcodes/brk ,scmp3 JSR ,find-opcode/on-brk JCN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&loop
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr ,scmp3 JSR ,&on-found JCN
		INC GTHk ,&loop JCN
	POP2 POP2r #00

JMP2r
	&on-found
		NIP ( LITk ) DUP #00 EQU #70 SFT ADD
		STH2r INC2 INC2 INC2 ,find-mode JSR ADD JMP2r
	&on-brk POP2 #01 JMP2r

@find-mode ( mode* -- byte )

	LITr 00
	&while
		LDAk LIT '2 EQU #50 SFT STH ADDr
		LDAk LIT 'r EQU #60 SFT STH ADDr
		LDAk LIT 'k EQU #70 SFT STH ADDr
		INC2 LDAk ,&while JCN
	POP2 STHr

JMP2r

@scmp3 ( a[3]* b[3]* -- flag )

	LDA2k STH2 INC2 INC2 SWP2
	LDA2k STH2 INC2 INC2 EQU2r
	LDA STH LDA STH EQUr
	ANDr STHr

JMP2r

@print-symbols ( -- )

	LIT '- #18 DEOk DEOk DEO #0a18 DEO

	;syms
	&while
		LIT '@ #18 DEO
		LDA2k ;print JSR2 #2018 DEO
		LIT '( #18 DEO
		INC2 INC2 DUP2 ;pstr JSR2
		LIT ') #18 DEO #0a18 DEO
		;scap JSR2 INC2 INC2k INC2 LDA ,&while JCN
	POP2

JMP2r

( assets )

@pass1
	'| :do-padabs '$ :do-padrel
	'@ :do-labtop '& :do-labsub
	'" :do-rawtxt '' :do-rawchr
	'. :do-neuzep ', :do-neurel
	'; :do-neuabs ': :do-neuraw
	'[ :do-ignore '] :do-ignore
	'# :do-lithex
	&err
	00 :do-errors
	&opcode
	00 :do-opcode
	&rawhex
	00 :do-rawhex

@pass2
	'| :do-padabs '$ :do-padrel
	'@ :do-neutop '& :do-ignore
	'" :do-rawtxt '' :do-rawchr
	'. :do-refzep ', :do-refrel
	'; :do-refabs ': :do-refraw
	'[ :do-ignore '] :do-ignore
	'# :do-lithex
	&err

@opcodes
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK

@errors
	&duplicate "Duplicate 20 "Label $1
	&unknown "Unknown 20 "Token $1
	&number "Invalid 20 "Number $1
	&padding "Invalid 20 "Padding $1
	&label "Unknown 20 "Label $1
	&far "Too 20 "Far $1

@error ( id* name* -- )

	;&err-txt ;perr JSR2
	;perr JSR2
	LIT ': #19 DEO
	#2019 DEO
	;perr JSR2
	#0a19 DEO
	#010e DEO
	#010f DEO

BRK
	&err-txt "!! 20 "Error 20 $1

@pstr ( str* -- ) &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@perr ( src* str* -- ) &w LDAk #19 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@scap ( str* -- end* ) LDAk #00 NEQ JMP JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR INC2k #00 ROT ROT STA STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scat ( src* dst* -- ) ,scap JSR
@scpy ( src* dst* -- ) STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@mclr ( src* len* -- ) OVR2 ADD2 SWP2 &l STH2k #00 STH2r STA INC2 GTH2k ,&l JCN POP2 POP2 JMP2r
@mcpy ( src* dst* len* -- ) SWP2 STH2 OVR2 ADD2 SWP2 &loop LDAk STH2kr STA INC2r INC2 GTH2k ,&loop JCN POP2 POP2 POP2r JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r

@shex ( str* -- short* )

	LIT2r 0000
	&while
		LITr 40 SFT2r
		LITr 00
		LDAk ,chex JSR STH ADD2r
		INC2 LDAk ,&while JCN
	POP2 STH2r

JMP2r

@sihx ( str* -- flag )

	&while
		LDAk ,chex JSR #ff NEQ ,&valid JCN
			POP2 #00 JMP2r &valid
		INC2 LDAk ,&while JCN
	POP2
	#01

JMP2r

@chex ( char -- value/ff )

	DUP #2f GTH OVR #3a LTH AND ,&n JCN
	DUP #60 GTH OVR #67 LTH AND ,&l JCN
		POP #ff

JMP2r
	&n #30 SUB JMP2r
	&l #57 SUB JMP2r

@print ( short* -- )

	SWP ,&byte JSR
	&byte ( byte -- ) DUP #04 SFT ,&char JSR
	&char ( char -- ) #0f AND DUP #09 GTH #27 MUL ADD #30 ADD #18 DEO

JMP2r

@print-mem ( addr* -- )

	STH2
	#0000
	&l
		#00 OVR STH2kr ADD2 LDA ,print/byte JSR
		DUP #0f AND #0f NEQ #16 MUL #0a ADD #18 DEO
		INC NEQk ,&l JCN
	POP2
	POP2r

JMP2r

@syms ( addr*, text, 00 )
