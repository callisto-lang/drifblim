( usage: drifblim.rom input.tal output.rom )

|10 @Console &vector $2 &read $1 &pad $4 &type $1 &write $1 &error $1
|a0 @File &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@halt $1
	@scan $1
	@head $2
	@length $2
	@src $1 &buf $30
	@dst $1 &buf $30
	@token $1 &buf $30
	@scope $30
	@sublabel $30

|0100

@on-reset ( -> )
	.Console/type DEI ?{ ;dict/usage <print-err>/ }
	;&await-src .Console/vector DEO2
	BRK
	&await-src ( -> )
		.Console/read DEI DUP [ LIT "^ ] EQU ?on-interactive
		.src zkey ?on-default
		BRK

(
@|modes )

@on-default ( -> )
	;&await-dst .Console/vector DEO2
	BRK
	&await-dst ( -> )
		.Console/read DEI .dst zkey ?{ BRK }
		<assemble>
		[ LIT2 80 -halt ] LDZ ORA #0f DEO
		BRK

@on-interactive ( c -> )
	POP ;&await-dst .Console/vector DEO2
	BRK
	&await-dst ( -> )
		.Console/read DEI .dst zkey ?{ BRK }
		;&await-src .Console/vector DEO2
		BRK
	&await-src ( -> )
		.Console/read DEI .src zkey ?{ BRK }
		<assemble>
		;dst/buf DUP2 <print-line>/
		<sclr>
		BRK

(
@|generics )

@<assemble> ( -- )
	( | setup export )
	<assemble>/clean
	( | clear memory )
	;<create-symbol>/ptr LDA2 ;memory <mclr>
	( | cleanup cache )
	[ LIT2 00 -halt ] STZ
	;memory/symbols ;<create-symbol>/ptr STA2
	#0000 ;<create-symbol>/count STA2
	( scan pass ) #01 handle-top ?&clean
	( write pass ) #00 handle-top ?&clean
	save-result save-symbols !<print-summary>
	&clean ( -- )
		;dst/buf .File/name DEO2
		[ LIT2 01 -File/delete ] DEO
		JMP2r

@handle-top ( scan -- err )
	.scan STZ
	#0100 <set-head>
	#00 ;lambda/count STA
	;dict/reset <set-scope>
	;src/buf handle-file .halt LDZ JMP2r

@handle-file ( f* -- )
	.File/name DEO2
	#0001 .File/length DEO2
	#0000
	&s ( len* -- )
		;&c read-eof ?&end
		INC2 [ LIT &c $1 ] handle-char !&s
	&end ( len* -- )
		ORA ?{
			;memory/include ;token/buf <scpy>
			;err/file <set-error> }
		JMP2r

@handle-char ( c -- )
	.token zkey ?{ JMP2r }
	;token/buf DUP2 parse !<sclr>

(
@|tokenizer )

@parse ( t* -- )
	LDAk [ LIT 28 ] EQU ?parse-comment
	( | runic )
	LDAk ,&rune STR
	;runes/end ;runes
	&l ( -- )
		LDAk [ LIT &rune $1 ] EQU ?parse-runic
		#0003 ADD2 GTH2k ?&l
	POP2 POP2
	( | non-runic )
	is-hex ?<write-hex>
	is-opcode ?parse-opcode
	!lib/litjsi

@parse-comment ( t* -- )
	;&c read-eof ?<sclr>
	[ LIT2 &c $1 28 ] NEQk ?{ ;err/nested <set-error> }
	INC NEQ ?parse-comment
	!<sclr>

@parse-runic ( t* a* b* -- )
	NIP2 INC2 LDA2
	( unsafe ) JMP2

@parse-opcode ( t* -- )
	find-opcode !<write>

@lib
	&padabs ( t* -- )
		INC2 get-hex !<set-head>
	&padrel ( t* -- )
		INC2 get-hex .head LDZ2 ADD2 !<set-head>
	&toplab ( t* -- )
		INC2 !<set-scope>
	&sublab ( t* -- )
		INC2 get-sublabel !<create-symbol>
	&litrel ( t* -- )
		#80 <write>
	&rawrel ( t* -- )
		INC2 get-ref get-rel !<write>
	&litzep ( t* -- )
		#80 <write>
	&rawzep ( t* -- )
		INC2 get-ref LDA2 NIP !<write>
	&litabs ( t* -- )
		#a0 <write>
	&rawabs ( t* -- )
		INC2 get-ref LDA2 !<write-short>
	&litjci ( t* -- )
		INC2 #20 !<write-call>
	&litjmi ( t* -- )
		INC2 #40 !<write-call>
	&litjsi ( t* -- )
		#60 !<write-call>
	&lithex ( t* -- )
		INC2 DUP zlen #04 EQU #50 SFT #80 ORA <write>
		!<write-hex>
	&rawstr ( t* -- )
		INC2 !<write-str>/
	&lambda ( t* -- )
		POP2 !lambda/pop
	&inc ( t* -- )
		INC2k ;memory/include STH2k <scpy>
		<sclr>
		STH2r !handle-file
	&ignore ( t* -- )
		POP2 JMP2r

(
@|primitives )

@<write-str> ( str* -- )
	&w ( -- )
		LDAk <write>
		INC2 & LDAk ?&w
	POP2 JMP2r

@<write-hex> ( str* -- )
	DUP zlen DUP #02 EQU ?&byte
	#04 EQU ?&short
	POP2 ;err/number !<set-error>
	&byte ( str* len -- )
		POP get-hex NIP !<write>
	&short ( str* short* -- )
		get-hex !<write-short>

@<write-call> ( str* opc -- )
	<write>
	get-ref LDA2 .head LDZ2 INC2 INC2 SUB2

@<write-short> ( short* -- )
	SWP <write>

@<write> ( byte -- )
	DUP .head LDZ2 INC2k STH2 ;rom ADD2 STA
	record-length STH2r

@<set-head> ( v* -- )
	.head STZ2
	JMP2r

@<set-error> ( name* -- )
	<print-error>
	[ LIT2 01 -halt ] STZ
	JMP2r

@record-length ( byte -- )
	?{ JMP2r }
	.scan LDZ ?{ JMP2r }
	.head LDZ2 OVR ?{ ;err/zeropage <set-error> }
	.length STZ2
	JMP2r

(
@|labels )

@get-sublabel ( name* -- sublabel* )
	DUP zlen .sublabel zlen ADD #30 LTH ?{ ;err/sublabel !<set-error> }
	[ LIT2 &ptr $2 ] <scpy>
	;sublabel JMP2r

@<set-scope> ( t* -- )
	DUP2 ;scope <scpy>
	DUP2 ;sublabel STHk <scpy>
	[ LIT2 "/ 00 ] STHr zcap/ STHk STZ2
	#00 STHr INC ,get-sublabel/ptr STR2
	( >> )

@<create-symbol> ( name* -- )
	.scan LDZ ?{ POP2 JMP2r }
	is-hex ?&invalid
	is-opcode ?&invalid
	DUP2 find-symbol INC2 ORA ?&not-unique
	.head LDZ2 [ LIT2 &ptr =memory/symbols ] STH2k STA2
	INC2r INC2r INC2r DUP2 STH2kr <scpy>
	slen STH2r ADD2 INC2 ,&ptr STR2
	[ LIT2 &count $2 ] INC2 ,&count STR2
	JMP2r
	&invalid ( name* -- )
		POP2 ;err/symbol !<set-error>
	&not-unique ( name* -- )
		POP2 ;err/duplicate !<set-error>

@find-symbol ( name* -- <addr>* )
	,&t STR2
	;<create-symbol>/ptr LDA2 ;memory/symbols
	&l ( -- )
		#0003 ADD2 DUP2 [ LIT2 &t $2 ] scmp ?&found
		scap/ INC2 GTH2k ?&l
	POP2 POP2 #ffff JMP2r
	&found ( symbols* -- <addr>* )
		#0003 SUB2 NIP2 JMP2r

@get-ref ( token* -- <label>* )
	LDAk [ LIT "{ ] NEQ ?{ lambda/push }
	.scan LDZ ?&scan
	LDAk [ LIT "& ] NEQ ?{ INC2 get-sublabel }
	find-symbol INC2k #0000 EQU2 ?{
		INC2k INC2 LDAk INC ROT ROT STA
		JMP2r }
	;err/reference <set-error>
	&scan POP2 ;&fill JMP2r
	&fill ffff "? $1

@lambda
	&push ( -- name* )
		[ LIT &count $1 ] INCk ,&count STR
		DUP [ LIT2 &ptr =memory/lambda ] INC2k ,&ptr STR2
		STA
		!lambda/name
	&pop ( -- )
		,&ptr LDR2 #0001 SUB2 LDAk lambda/name <create-symbol>
		,&ptr STR2
		JMP2r
	&name ( id -- str* )
		( x0 ) DUP #04 SFT hexc
		( 0x ) SWP hexc ,&id STR2
		;&sym JMP2r
		&sym "lambda &id "00 $1

(
@|helpers )

@get-hex ( str* -- value* )
	is-hex ?{ ;err/number !<set-error> }
	[ LIT2r 0000 ]
	&w ( -- )
		( acc ) [ LITr 40 ] SFT2r
		( res ) LDAk chex [ LITr 00 ] STH ADD2r INC2 LDAk ?&w
	POP2 STH2r JMP2r

@get-rel ( label* -- distance )
	.scan LDZ ?&fill
	LDA2 .head LDZ2 SUB2 #0002 SUB2
	( bounds ) DUP2 #0080 ADD2 POP ?&fail
	NIP JMP2r
	&fail ( label* distance* -- distance )
		;err/distance <set-error>
	&fill ( -- )
		POP2 #ff JMP2r

@is-hex ( str* -- str* f )
	DUP2
	&w ( -- )
		LDAk chex INC ?{ POP2 #00 JMP2r }
		INC2 LDAk ?&w
	POP2 #01 JMP2r

@is-opcode ( str* -- str* f )
	DUP2 find-opcode ?{ DUP2 ;opcodes/brk !scmp3 }
	#01 JMP2r

@find-opcode ( name* -- byte )
	STH2 #2000
	&l ( -- )
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr scmp3 ?&on-found
		INC GTHk ?&l
	POP2 POP2r #00 JMP2r
	&on-found ( `name* bounds* -- byte )
		( add keep mode to LIT ) NIP DUP #00 EQU #70 SFT ORA
		( move to modes ) STH2r #0003 ADD2
		( keep flag ) [ LITr 00 ]
	&w ( -- )
		LDAk #20 OVR [ LIT "2 ] EQU ?&>end
		DUP ADD OVR [ LIT "r ] EQU ?&>end
		DUP ADD OVR [ LIT "k ] EQU ?&>end
		DUP ADD OVR #00 EQU ?&>end
			;err/opcode <set-error> &>end
		NIP STH ORAr INC2 LDAk ?&w
	POP2 STHr ADD JMP2r

@save-symbols ( -- )
	;dst/buf DUP2 scap/ ;dict/sym-ext OVR2 <scpy>
	SWP2 .File/name DEO2
	;memory/symbols
	&w ( -- )
		( | addr )
		#0002 .File/length DEO2
		DUP2 .File/write DEO2
		( | name )
		#0003 ADD2 DUP2 slen INC2 STH2k .File/length DEO2
		DUP2 .File/write DEO2
		STH2r ADD2 DUP2 #0003 ADD2 LDA ?&w
	POP2 #00 ROT ROT STA
	JMP2r

@save-result ( -- )
	;dst/buf .File/name DEO2
	.length LDZ2 #00ff SUB2 .File/length DEO2
	;rom/output .File/write DEO2
	JMP2r

@read-eof ( addr* -- f )
	.File/read DEO2
	.File/success DEI2 #0000 EQU2 JMP2r

@<print-summary> ( -- )
	;<create-symbol>/ptr LDA2 ;memory/symbols
	&l ( -- )
		INC2k INC2 LDA ?&>skip
		#0003 ADD2 LDAk [ LIT "A ] SUB #1a LTH ?&>skip
		LDAk [ LIT 28 ] EQU ?&>skip
		DUP2 ;dict/reset scmp ?&>skip
			;dict/unused <print-err>/
			DUP2 <print-err>/
			#0a19 DEO &>skip
		scap/ INC2 GTH2k ?&l
	POP2 POP2
	( | result )
	;dict/assembled <print-err>/
	;dst/buf <print-err>/
	( | length )
	;dict/in <print-err>/
	.length LDZ2 #00ff SUB2 <print-dec>
	;dict/bytes <print-err>/
	;<create-symbol>/count LDA2 <print-dec>
	;dict/labels !<print-err>/

(
@|stdlib )

@zkey ( key ztr -- proc )
	OVR #21 LTH ?&eval
	LDZk #2f EQU ?&overflow
	( write char ) STH #00 STHkr LDZk ADD INC STZ2
	( incr len ) STHr LDZk INC SWP STZ
	#00 JMP2r
	&overflow ( key ztr -- proc )
		;err/token <set-error>
	&eval ( key ztr -- proc )
		NIP LDZk #00 ROT STZ
		JMP2r

@zcap ( ztr/buf -- ztr/cap )
	&w ( -- )
		INC & LDZk ?&w
	JMP2r

@zlen ( ztr/buf -- len )
	DUP zcap/ SWP SUB JMP2r

@scap ( str* -- end* )
	&w ( -- )
		INC2 & LDAk ?&w
	JMP2r

@slen ( str* -- len* )
	DUP2 scap/ SWP2 SUB2 JMP2r

@scmp ( a* b* -- f )
	STH2
	&l ( a* b* -- f )
		LDAk LDAkr STHr NEQk ?&d
		DUP EOR EQUk ?&d
		POP2 INC2 INC2r !&l
	&d ( a* c1 c2 b* -- f )
		NIP2 POP2r EQU JMP2r

@scmp3 ( a* b* -- f )
	STH2 LDAkr LDAk STHr NEQ ?{ INC2r INC2 }
	LDA2r LDA2 STH2r EQU2 JMP2r

@chex ( c -- <val> )
	[ LIT "0 ] SUB DUP #0a LTH ?&>end
	#27 SUB DUP #10 LTH ?&>end
		POP #ff &>end
	JMP2r

@hexc ( id -- char )
	#0f AND DUP #09 GTH #27 MUL ADD LIT "0 ADD JMP2r

@<mclr> ( to* from* -- )
	&l ( -- )
		#0000 OVR2 STA2
		INC2 INC2 GTH2k ?&l
	POP2 POP2 JMP2r

@<scpy> ( src* dst* -- )
	STH2
	&w ( -- )
		LDAk #00 STH2kr STA2
		INC2r INC2 LDAk ?&w
	POP2 POP2r JMP2r

@<sclr> ( str* -- )
	#00 ROT ROT
	&w ( -- )
		STAk
		INC2 LDAk ?&w
	STA
	JMP2r

@<print-line> ( str* -- )
	&w ( str* -- )
		LDAk #18 DEO
		INC2 & LDAk ?&w
	POP2 #0a18 DEO
	JMP2r

@<print-err> ( str* -- )
	&w ( str* -- )
		LDAk #19 DEO
		INC2 & LDAk ?&w
	POP2 JMP2r

@<print-dec> ( short* -- )
	#2710 [ LIT2r 00fb ]
	&w ( -- )
		DIV2k #000a DIV2k MUL2 SUB2 SWPr EQUk OVR STHkr EQU AND ?{
			DUP [ LIT "0 ] ADD #19 DEO
			INCr }
		POP2 #000a DIV2 SWPr INCr STHkr ?&w
	POP2r POP2 POP2 JMP2r

@<print-error> ( err* -- )
	;err <print-err>
	<print-err>
	#2019 DEO
	;token/buf <print-err>
	;dict/in <print-err>/
	;scope <print-err>/
	#0a19 DEO
	JMP2r

(
@|assets )

@dict &usage "usage: 20 "drifblim.rom 20 "in.tal 20 "out.rom 0a $1
	&unused "-- 20 "Unused: 20 $1
	&reset "RESET $1
	&assembled "Assembled 20 $1
	&in 20 "in 20 $1
	&bytes 20 "bytes( $1
	&labels 20 "labels). 0a $1
	&sym-ext ".sym $1

@err
	"!! 20 "Error: 20 $1
	&file "File $1
	&duplicate "Duplicate $1
	&number "Number $1
	&reference "Reference $1
	&distance "Distance $1
	&symbol "Symbol $1
	&token "Token $1
	&sublabel "Sublabel $1
	&opcode "Opcode $1
	&nested "Nested $1
	&zeropage "Zero-page $1

@opcodes
	[
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK ]

@runes
	[
	"| =lib/padabs "$ =lib/padrel
	"@ =lib/toplab "& =lib/sublab
	", =lib/litrel "_ =lib/rawrel
	". =lib/litzep "- =lib/rawzep
	"; =lib/litabs "= =lib/rawabs
	"? =lib/litjci "! =lib/litjmi
	5b =lib/ignore 5d =lib/ignore
	"} =lib/lambda "# =lib/lithex
	"" =lib/rawstr "~ =lib/inc ]
	&end

(
@|memory )

@memory ( buffers )
	&include $30
	&lambda $100
	&symbols ( addr*, refs, name[], 00 )

|8000

@rom ( output )
	&zeropage $100
	&output

