( uxnasm src/symbols.tal bin/sym.rom && uxncli bin/sym.rom examples/hello.tal bin/test.rom )

|10 @Console &vector $2 &read $1 &pad $5 &write $1 &err $1
|a0 @File1 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2
|b0 @File2 &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2

|0000

	@src $30
	@dst $30
	@include $30
	@program &head $2

|0100 ( -> )

	( interactive )
	;await-src .Console/vector DEO2
	;dict/input ;pstr JSR2

BRK

@await-src ( -> ) .Console/read DEI .src ;skey JSR2 ,ready-dst JCN BRK
@ready-dst ( -> ) ;await-dst .Console/vector DEO2 ;dict/output ;pstr JSR2 BRK
@await-dst ( -> ) .Console/read DEI .dst ;skey JSR2 ,on-ready JCN BRK

@on-ready ( -> )

	#0a18 DEO
	;src ;handle-file JSR2
	( debug ) #010e DEO
	( halt ) #010f DEO

BRK

(
@|generics )

@handle-file ( f* -- )

	.File1/name DEO2
	#0001 .File1/length DEO2
	&s
		;&c .File1/read DEO2
		.File1/success DEI2 #0000 NEQ2 ,&continue JCN JMP2r
		&continue [ LIT &c $1 ] ,handle-char JSR
		,&s JMP

JMP2r

@handle-char ( c -- )

	#20 GTHk NIP ,&append JCN POP
	;token LDAk ,&run JCN POP2

JMP2r
	&append ( c -- ) ;token DUP2 ;slen JSR2 #001f LTH2 ;sput JCN2 POP JMP2r
	&run ( t* -- ) DUP2 ,handle-token JSR ;sclr JMP2

@handle-token ( t* -- )

	( DUP2 ;pstr JSR2 #2018 DEO .program/head LDZ2 ;phex JSR2 #0a18 DEO )

	LDAk LIT "( EQU ,&on-parens JCN
	LDAk LIT ") EQU ,&on-parens JCN
	[ LIT &sleep $1 ] ,&on-sleep JCN
	;parse JSR2

JMP2r
	&on-parens ( t* -- ) LDA LIT "( EQU ,&sleep STR JMP2r
	&on-sleep ( t* -- ) POP2 JMP2r

(
@|library )

@parse ( t* -- )

	LDAk ,&rune STR
	( runes )
	;runes/err ;runes
	&l
		LDAk [ LIT &rune $1 ] NEQ ,&no-runic JCN
			NIP2 INC2 LDA2 JMP2
			&no-runic
		#0003 ADD2 GTH2k ,&l JCN
	POP2 POP2
	( non-runic )
	DUP2 ;is-hex JSR2 ;library/do-rawhex JCN2
	DUP2 ;is-opcode JSR2 ;library/do-opcode JCN2
	( jsi )
	;library/do-litjsi JSR2

JMP2r

@library
( head )
&do-padabs INC2 ;shex JSR2 ;set-head JMP2
&do-padrel INC2 ;shex JSR2 ;move-head JMP2
( labels )
&do-toplab INC2 ;set-scope JSR2 ;create-label JMP2
&do-sublab INC2 ;make-sublabel JSR2 ;create-label JMP2
( addressing )
&do-litrel #80 ;write JSR2 
&do-rawrel INC2 ;get-ref JSR2 ;get-rel JSR2 ;write JMP2
&do-litzep #80 ;write JSR2
&do-rawzep INC2 ;get-ref JSR2 LDA2 NIP ;write JMP2
&do-litabs #a0 ;write JSR2 
&do-rawabs INC2 ;get-ref JSR2 LDA2 ;write-short JMP2
( calls )
&do-litjmi #20 ;write JSR2 INC2 ;get-ref JSR2 LDA2 ;write-short JMP2
&do-litjci #40 ;write JSR2 INC2 ;get-ref JSR2 LDA2 ;write-short JMP2
&do-litjsi #60 ;write JSR2 INC2 ;get-ref JSR2 LDA2 ;write-short JMP2
( hexadecimals )
&do-rawhex ;write-rawhex JMP2
&do-lithex INC2 ;write-lithex JMP2
( etc )
&do-rawstr INC2 ;write-rawstr JMP2
&do-opcode ;find-opcode JSR2 ;write JMP2
&do-inc INC2k ;include STH2k ;scpy JSR2 ;sclr JSR2 STH2r ;handle-file JMP2
&do-ignore POP2 JMP2r

(
@|primitives )

@write-short ( short* -- )

	SWP ,write JSR

@write ( byte -- )

	;phex/b JSR2 #0a18 DEO

	( move )
	.program/head LDZ2k INC2 ROT STZ2

JMP2r

@write-rawstr ( str* -- )

	&w
		LDAk ;write JSR2
		INC2 LDAk ,&w JCN
	POP2

JMP2r

@write-rawhex ( str* -- )

	DUP2 ;is-hex JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		;shex JSR2 ,write-short JMP
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		;shex JSR2 NIP ,write JMP
		&no-byte
	&invalid
	;err/number ;crash ( .. )

JMP2

@write-lithex ( str* -- )

	DUP2 ;is-hex JSR2 #00 EQU ,&invalid JCN
	DUP2 ;slen JSR2 #0004 NEQ2 ,&no-short JCN
		#0a ;write JSR2
		;shex JSR2 ;write-short JMP2
		&no-short
	DUP2 ;slen JSR2 #0002 NEQ2 ,&no-byte JCN
		#80 ;write JSR2
		;shex JSR2 NIP ;write JMP2
		&no-byte
	&invalid
	;err/number ;crash ( .. )

JMP2


@set-scope ( t* -- name* )

	;scope OVR2 SWP2 ;scpy ( .. )

JMP2

@get-rel ( label* -- distance )

	LDA2k .program/head LDZ2 SUB2 #0003 SUB2
	DUP2 #0080 ADD2 POP ,&fail JCN
	NIP2 NIP

JMP2r
	&fail POP2 INC2 INC2 INC2 ;err/distance ;crash JMP2

@get-ref ( token* -- <label*> )

	LDAk LIT "& NEQ ,&no-sub JCN
		INC2 ;make-sublabel JSR2
		&no-sub
	;find-label JSR2
		INC2k ORA ,&found JCN
			POP2 ;err/reference ;crash JMP2
			&found

	( count ) INC2k INC2 LDAk INC ROT ROT STA

JMP2r

@create-label ( name* -- )

	( check duplicate ) DUP2 ;find-label JSR2 INC2 ORA ,&not-unique JCN
	( save addr ) .program/head LDZ2 [ LIT2 &ptr =symbols ] STH2k STA2
	( move ) INC2r INC2r INC2r
	( save name ) DUP2 STH2kr ;scpy JSR2
	( move ) ;slen JSR2 STH2r ADD2 INC2 ,&ptr STR2
	( stats ) [ LIT2 &count $2 ] INC2 ,&count STR2

JMP2r
	&not-unique ;err/duplicate ;crash JMP2

@make-sublabel ( name* -- sublabel* )

	;scope ;sublabel STH2k ;scpy JSR2
	LIT "/ STH2kr ;sput JSR2
	STH2kr ;scat JSR2
	STH2r

JMP2r

@find-label ( name* -- <addr*> )

	STH2
	;symbols
	&w
		INC2 INC2 INC2 DUP2 STH2kr ;scmp JSR2 ,&found JCN
		;scap JSR2 INC2 INC2k INC2 INC2 LDA ,&w JCN
	POP2
	POP2r
	#ffff

JMP2r
	&found #0003 SUB2 POP2r JMP2r

@put-str ( s* -- )  JMP2r
@move-head ( v* -- ) .program/head LDZ2 ADD2
@set-head ( v* -- ) .program/head STZ2 JMP2r

(
@helpers )

@is-hex ( str* -- flag )

	&w
		LDAk ;chex JSR2 INC ,&valid JCN
			POP2 #00 JMP2r &valid
		INC2 LDAk ,&w JCN
	POP2
	#01

JMP2r

@is-opcode ( string* -- flag )

	DUP2 ;opcodes/brk ;scmp3 JSR2 ,find-opcode/on-brk JCN

@find-opcode ( name* -- byte )

	STH2
	#2000
	&l
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr ;scmp3 JSR2 ,&on-found JCN
		INC GTHk ,&l JCN
	POP2 POP2r #00

JMP2r
	&on-found
		NIP ( LITk ) DUP #00 EQU #70 SFT ADD
		STH2r INC2 INC2 INC2 ,find-modes JSR ADD JMP2r
	&on-brk POP2 #01 JMP2r

@find-modes ( mode* -- byte )

	LITr 00
	&w
		LDAk #20
		OVR LIT "2 EQU ,&end JCN DUP ADD
		OVR LIT "r EQU ,&end JCN DUP ADD
		OVR LIT "k EQU ,&end JCN DUP ADD
		OVR #21 LTH ,&end JCN
			;token ;err/mode ;crash JMP2
		&end NIP STH ORAr
		INC2 LDAk ,&w JCN
	POP2 STHr

JMP2r

@crash ( id* name* -- )

	;err ;perr JSR2
	;perr JSR2
	LIT ": #19 DEO
	#2019 DEO
	;perr JSR2
	#0a19 DEO
	#010f DEO

BRK

@scmp3 ( a* b* -- flag )

	LDA2k ROT2 LDA2k ROT2 EQU2 STH
	INC2 LDA2 SWP2 INC2 LDA2 EQU2 STHr
	AND

JMP2r

(
@|stdlib )

@phex ( short* -- )

	SWP ,&b JSR
	&b ( byte -- ) DUP #04 SFT ,&c JSR
	&c ( char -- ) #0f AND DUP #09 GTH #27 MUL ADD #30 ADD #18 DEO

JMP2r

@perr ( src* str* -- ) &w LDAk #19 DEO INC2 LDAk ,&w JCN POP2 JMP2r


@pstr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r
@scap ( str* -- end* ) LDAk ,&w JCN JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR INC2k #00 ROT ROT STA STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scat ( src* dst* -- ) ,scap JSR
@scpy ( src* dst* -- ) OVR2 LDA ,&e JCN POP2 POP2 JMP2r &e STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@sclr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w STH2k #00 STH2r STA INC2 LDAk ,&w JCN POP2 JMP2r
@skey ( key buf -- proc ) OVR #21 LTH ,&eval JCN #00 SWP ;sput JSR2 #00 JMP2r &eval POP2 #01 JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r
@mcpy ( src* dst* len* -- ) SWP2 STH2 OVR2 ADD2 SWP2 &loop LDAk STH2kr STA INC2r INC2 GTH2k ,&loop JCN POP2 POP2 POP2r JMP2r
@chex ( c -- val|ff ) LIT "0 SUB DUP #09 GTH JMP JMP2r #27 SUB DUP #0f GTH JMP JMP2r POP #ff JMP2r
@shex ( str* -- val* ) LIT2r 0000 &w LITr 40 SFT2r LITr 00 LDAk ,chex JSR STH ADD2r INC2 LDAk ,&w JCN POP2 STH2r JMP2r

@dict
	&input "Input(.tal): 20 $1
	&output "Output(.rom): 20 $1

@err
	"!! 20 "Error 20 $1
	&duplicate "Duplicate  $1
	&token "Token $1
	&number "Number $1
	&reference "Reference $1
	&source "Source $1
	&mode "Mode $1
	&distance "Distance $1

@opcodes
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK

@runes
	"| =library/do-padabs "$ =library/do-padrel
	"@ =library/do-toplab "& =library/do-sublab
	", =library/do-litrel "_ =library/do-rawrel
	". =library/do-litzep "- =library/do-rawzep
	"; =library/do-litabs "= =library/do-rawabs
	"? =library/do-litjmi "! =library/do-litjci
	"[ =library/do-ignore "] =library/do-ignore
	"# =library/do-lithex "" =library/do-rawstr
	"~ =library/do-inc
	&err

(
@|buffers )

@token $20
@scope $20
@sublabel $20

(
@|memory )

@symbols ( addr*, refs, text, 00 ) $4000

@rom 


