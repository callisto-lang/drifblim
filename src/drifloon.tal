( usage: cat file.tal | drifloon.rom > output.rom )

|10 @Console &vector $2 &read $1 &pad $4 &type $1 &write $1 &error $1

|0000

	@pc $2
	@scope $2

|0100

@on-reset ( -> )
	;on-console .Console/vector DEO2
	BRK

@on-console ( -> )
	.Console/read DEI DUP ?{
		POP <assemble>
		#010e DEO
		BRK }
	<read>
	BRK

(
@|loader )

@<read> ( chr -- )
	( normalize ) #20 GTHk [ JMP SWP POP ]
	( join ) [ LIT &last-a 20 ] OVR ,&last-a STR
	( skip ) DUP2 #2020 EQU2 ?&end
	#20 NEQ ?{
		DUP [ LIT "[ ] EQU ?&skip
		DUP [ LIT "] ] EQU ?&skip
		DUP [ LIT "( ] EQU ?<toggle-mute>
		DUP [ LIT ") ] EQU ?<toggle-mute> }
	[ LIT &mute 00 ] ?{ &skip POP JMP2r }
	( join ) [ LIT &last-b 20 ] OVR ,&last-b STR
	( skip ) DUP2 #2020 EQU2 ?&end
	POP #00 [ LIT2 &ptr =mem ] STA2k INC2 ,&ptr STR2
	&end ( chr last -- )
		POP2 JMP2r

@<toggle-mute> ( chr -- )
	[ LIT "( ] SUB ;<read>/mute STA
	JMP2r

(
@|assembly )

@<assemble> ( -- )
	( explode ) ;mem <sexp>
	<pass1>
	( <print-source> ) JMP2r

@<pass1> ( -- )
	#0100 <set-pc>
	;<read>/ptr LDA2 INC2 ;<create-symbol>/ptr STA2
	;mem
	&w ( -- )
		<parse-token>
		scap/ INC2 LDAk ?&w
	POP2 JMP2r

@<parse-token> ( token* -- token* )
	LDAk [ LIT "@ ] EQU ?<create-label>
	LDAk [ LIT "& ] EQU ?<create-sublabel>
	LDAk [ LIT "? ] EQU ?&move-3
	LDAk [ LIT "! ] EQU ?&move-3
	LDAk [ LIT "; ] EQU ?&move-3
	LDAk [ LIT "= ] EQU ?&move-2
	LDAk [ LIT ". ] EQU ?&move-2
	LDAk [ LIT ", ] EQU ?&move-2
	LDAk [ LIT "- ] EQU ?&move-1
	LDAk [ LIT "_ ] EQU ?&move-1
	LDAk [ LIT "" ] EQU ?&string
	LDAk [ LIT "# ] EQU ?&lithex
	is-hex ?&rawhex
	is-opcode ?&move-1
	&move-3 ( t* -- t* )
		#0003 !<move-pc>
	&move-2 ( t* -- t* )
		#0002 !<move-pc>
	&move-1 ( t* -- t* )
		#0001 !<move-pc>
	&string ( t* -- t* )
		INC2k slen !<move-pc>
	&lithex ( t* -- t* )
		INC2k slen #01 SFT2 INC2 !<move-pc>
	&rawhex ( t* -- t* )
		DUP2 slen #01 SFT2 !<move-pc>

@<move-pc> ( offset* -- )
	.pc LDZ2 ADD2
	( >> )

@<set-pc> ( addr* -- )
	.pc STZ2
	JMP2r

@<create-label> ( token* -- token* )
	INC2k !<create-symbol>

@<create-sublabel> ( token* -- token* )
	DUP2

@<create-symbol> ( t* -- )
	( | print )
	.pc LDZ2 <phex>
	#2018 DEO
	DUP2 <pstr>
	#0a18 DEO
	( | records: name* addr* refs )
	[ LIT2 &ptr $2 ] STH2k STA2
	.pc LDZ2 INC2r INC2r STH2kr STA2
	#00 STH2r STA
	JMP2r

@<set-scope> ( t* -- )
	.scope STZ2
	JMP2r

(
@|helpers )

@is-hex ( str* -- str* f )
	DUP2
	&w ( -- )
		LDAk chex INC ?{ POP2 #00 JMP2r }
		INC2 LDAk ?&w
	POP2 #01 JMP2r

@is-opcode ( str* -- str* f )
	DUP2 find-opcode ?{ DUP2 ;opcodes/brk !scmp3 }
	#01 JMP2r

@find-opcode ( name* -- byte )
	STH2
	#2000
	&l ( -- )
		#00 OVR #03 MUL ;opcodes ADD2 STH2kr scmp3 ?&on-found
		INC GTHk ?&l
	POP2 POP2r #00 JMP2r
	&on-found ( `name* bounds* -- byte )
		( add keep mode to LIT ) NIP DUP #00 EQU #70 SFT ORA
		( move to modes ) STH2r #0003 ADD2
		( keep flag ) [ LITr 00 ]
	&w ( -- )
		LDAk #20 OVR [ LIT "2 ] EQU ?&>end
		DUP ADD OVR [ LIT "r ] EQU ?&>end
		DUP ADD OVR [ LIT "k ] EQU ?&>end
			&>end
		NIP STH
		ORAr INC2 LDAk ?&w
	POP2 STHr ADD JMP2r

@<print-source> ( -- )
	;mem
	&w ( -- )
		LDAk #20 GTHk [ JMP SWP POP ] #18 DEO
		&resume INC2 LDA2k ORA ?&w
	POP2 #0a18 DEOk DEO
	JMP2r

(
@|stdlib )

@chex ( c -: <val> )
	[ LIT "0 ] SUB DUP #0a LTH ?&>end
	#27 SUB DUP #10 LTH ?&>end
		POP #ff &>end
	JMP2r

@scmp3 ( a* b* -- f )
	STH2
	LDAkr LDAk STHr NEQ ?{ INC2r INC2 }
	LDA2r LDA2 STH2r EQU2 JMP2r

@scap ( str* -: end* )
	INC2 & LDAk ?scap
	JMP2r

@slen ( str* -: len* )
	DUP2 scap/ SWP2 SUB2 JMP2r

@<sexp> ( str* -- )
	#00 ROT ROT
	&w ( -- )
		LDAk #20 GTH ?{ STAk }
		INC2 LDAk ?&w
	STA
	JMP2r

@<pstr> ( str* -- )
	LDAk #18 DEO
	INC2 & LDAk ?<pstr>
	POP2 JMP2r

@<phex> ( short* -- )
	SWP <phex>/b
	&b ( -- )
		DUP #04 SFT <phex>/c
	&c ( -- )
		#0f AND DUP #09 GTH #27 MUL ADD [ LIT "0 ] ADD #18 DEO
		JMP2r

(
@|memory )

@opcodes [
	"LIT "INC "POP "NIP "SWP "ROT "DUP "OVR
	"EQU "NEQ "GTH "LTH "JMP "JCN "JSR "STH
	"LDZ "STZ "LDR "STR "LDA "STA "DEI "DEO
	"ADD "SUB "MUL "DIV "AND "ORA "EOR "SFT
	&brk "BRK ]

@mem


